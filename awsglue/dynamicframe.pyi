from awsglue.utils import callsite as callsite, iteritems as iteritems, itervalues as itervalues, makeOptions as makeOptions
from typing import Any

long = int
basestring = str
unicode = str
imap = map
ifilter = filter

class ResolveOption:
    path: Any
    action: Any
    target: Any
    def __init__(self, path, action, target: Any | None = ...) -> None: ...

class DynamicFrame:
    glue_ctx: Any
    name: Any
    def __init__(self, jdf, glue_ctx, name: str = ...) -> None: ...
    def with_frame_schema(self, schema): ...
    def schema(self): ...
    def show(self, num_rows: int = ...) -> None: ...
    def filter(self, f, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def mapPartitions(self, f, preservesPartitioning: bool = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def map(self, f, preservesPartitioning: bool = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def mapPartitionsWithIndex(self, f, preservesPartitioning: bool = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def printSchema(self) -> None: ...
    def toDF(self, options: Any | None = ...): ...
    @classmethod
    def fromDF(cls, dataframe, glue_ctx, name): ...
    def unbox(self, path, format, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ..., **options): ...
    def drop_fields(self, paths, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def select_fields(self, paths, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def split_fields(self, paths, name1, name2, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def split_rows(self, comparison_dict, name1, name2, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def rename_field(self, oldName, newName, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def write(self, connection_type, connection_options=..., format: Any | None = ..., format_options=..., accumulator_size: int = ...): ...
    def count(self): ...
    def spigot(self, path, options=..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def join(self, paths1, paths2, frame2, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def unnest(self, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def relationalize(self, root_table_name, staging_path, options=..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def applyMapping(self, *args, **kwargs): ...
    def apply_mapping(self, mappings, case_sensitive: bool = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def resolveChoice(self, specs: Any | None = ..., choice: str = ..., database: Any | None = ..., table_name: Any | None = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ..., catalog_id: Any | None = ...): ...
    def mergeDynamicFrame(self, stage_dynamic_frame, primary_keys, transformation_ctx: str = ..., options=..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def union(self, other_frame, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def getNumPartitions(self): ...
    def repartition(self, num_partitions, transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def coalesce(self, num_partitions, shuffle: bool = ..., transformation_ctx: str = ..., info: str = ..., stageThreshold: int = ..., totalThreshold: int = ...): ...
    def errorsAsDynamicFrame(self): ...
    def errorsCount(self): ...
    def stageErrorsCount(self): ...
    def assertErrorThreshold(self): ...

class DynamicFrameCollection:
    def __init__(self, dynamic_frames, glue_ctx) -> None: ...
    def __getitem__(self, key): ...
    def __len__(self): ...
    def keys(self): ...
    def values(self): ...
    def select(self, key, transformation_ctx: str = ...): ...
    def map(self, callable, transformation_ctx: str = ...): ...
    def flatmap(self, f, transformation_ctx: str = ...): ...

class DynamicFrameReader:
    def __init__(self, glue_context) -> None: ...
    def from_rdd(self, data, name, schema: Any | None = ..., sampleRatio: Any | None = ...): ...
    def from_options(self, connection_type, connection_options=..., format: Any | None = ..., format_options=..., transformation_ctx: str = ..., push_down_predicate: str = ..., **kwargs): ...
    def from_catalog(self, database: Any | None = ..., table_name: Any | None = ..., redshift_tmp_dir: str = ..., transformation_ctx: str = ..., push_down_predicate: str = ..., additional_options=..., catalog_id: Any | None = ..., **kwargs): ...

class DynamicFrameWriter:
    def __init__(self, glue_context) -> None: ...
    def from_options(self, frame, connection_type, connection_options=..., format: Any | None = ..., format_options=..., transformation_ctx: str = ...): ...
    def from_catalog(self, frame, database: Any | None = ..., table_name: Any | None = ..., redshift_tmp_dir: str = ..., transformation_ctx: str = ..., additional_options=..., catalog_id: Any | None = ..., **kwargs): ...
    def from_jdbc_conf(self, frame, catalog_connection, connection_options=..., redshift_tmp_dir: str = ..., transformation_ctx: str = ...): ...
